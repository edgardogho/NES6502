ca65 V2.16 - Ubuntu 2.16-2
Main file   : mario.s
Current file: mario.s

000000r 1               .linecont       +               ; Permitir continuar lineas
000000r 1               .feature        c_comments      /* Soportar comentarios tipo C */
000000r 1               
000000r 1               ;;Este programa utiliza mario.chr como rom de caracteres y sprites
000000r 1               ;; Dibuja un mapa (NewWorld) basico con un tubo, algunas nubes solidas
000000r 1               ;; y ladrillos como plataforma. Dibuja un solo BOX (?) el cual cuando
000000r 1               ;; es golpeado por debajo muesta un hongo (fijo). Al comerlo mario
000000r 1               ;; escucha Lucy in the Sky with diamonds mientras el cielo cambia de
000000r 1               ;; color.
000000r 1               
000000r 1               ;; El Sprite de mario se dibuja de acuerdo a su estado. Cuando corre
000000r 1               ;; para un costado se muestra el movimiento. Cuando se queda quieto
000000r 1               ;; mira para el ultimo lado. Cuando salta levanta la mano y cuando cae
000000r 1               ;; junta los brazos. Tiene soporte de gravedad.
000000r 1               
000000r 1               ;; Mapa dibujado con NES Screen Tool
000000r 1               
000000r 1               ;; Autor Edgardo Gho
000000r 1               ;; Junio 2020
000000r 1               
000000r 1               ;;El archivo mario.chr es propiedad de Nintendo.
000000r 1               
000000r 1               ;;Declaramos constantes
000000r 1               JOYPAD1 = $4016
000000r 1               JOYPAD2 = $4017
000000r 1               BUTTON_A      = 1 << 7
000000r 1               BUTTON_B      = 1 << 6
000000r 1               BUTTON_SELECT = 1 << 5
000000r 1               BUTTON_START  = 1 << 4
000000r 1               BUTTON_UP     = 1 << 3
000000r 1               BUTTON_DOWN   = 1 << 2
000000r 1               BUTTON_LEFT   = 1 << 1
000000r 1               BUTTON_RIGHT  = 1 << 0
000000r 1               
000000r 1               ;Hacemos definiciones MACROS para que los colores
000000r 1               ;sean mas faciles de utilizar
000000r 1               ;Tomado de:
000000r 1               ;https://github.com/battlelinegames/nes-starter-kit
000000r 1               DARK_GRAY = $00
000000r 1               MEDIUM_GRAY = $10
000000r 1               LIGHT_GRAY = $20
000000r 1               LIGHTEST_GRAY = $30
000000r 1               
000000r 1               DARK_BLUE = $01
000000r 1               MEDIUM_BLUE = $11
000000r 1               LIGHT_BLUE = $21
000000r 1               LIGHTEST_BLUE = $31
000000r 1               
000000r 1               DARK_INDIGO = $02
000000r 1               MEDIUM_INDIGO = $12
000000r 1               LIGHT_INDIGO = $22
000000r 1               LIGHTEST_INDIGO = $32
000000r 1               
000000r 1               DARK_VIOLET = $03
000000r 1               MEDIUM_VIOLET = $13
000000r 1               LIGHT_VIOLET = $23
000000r 1               LIGHTEST_VIOLET = $33
000000r 1               
000000r 1               DARK_PURPLE = $04
000000r 1               MEDIUM_PURPLE = $14
000000r 1               LIGHT_PURPLE = $24
000000r 1               LIGHTEST_PURPLE = $34
000000r 1               
000000r 1               DARK_REDVIOLET = $05
000000r 1               MEDIUM_REDVIOLET = $15
000000r 1               LIGHT_REDVIOLET = $25
000000r 1               LIGHTEST_REDVIOLET = $35
000000r 1               
000000r 1               DARK_RED = $06
000000r 1               MEDIUM_RED = $16
000000r 1               LIGHT_RED = $26
000000r 1               LIGHTEST_RED = $36
000000r 1               
000000r 1               DARK_ORANGE = $07
000000r 1               MEDIUM_ORANGE = $17
000000r 1               LIGHT_ORANGE = $27
000000r 1               LIGHTEST_ORANGE = $37
000000r 1               
000000r 1               DARK_YELLOW = $08
000000r 1               MEDIUM_YELLOW = $18
000000r 1               LIGHT_YELLOW = $28
000000r 1               LIGHTEST_YELLOW = $38
000000r 1               
000000r 1               DARK_CHARTREUSE = $09
000000r 1               MEDIUM_CHARTREUSE = $19
000000r 1               LIGHT_CHARTREUSE = $29
000000r 1               LIGHTEST_CHARTREUSE = $39
000000r 1               
000000r 1               DARK_GREEN = $0a
000000r 1               MEDIUM_GREEN = $1a
000000r 1               LIGHT_GREEN = $2a
000000r 1               LIGHTEST_GREEN = $3a
000000r 1               
000000r 1               DARK_CYAN = $0b
000000r 1               MEDIUM_CYAN = $1b
000000r 1               LIGHT_CYAN = $2b
000000r 1               LIGHTEST_CYAN = $3b
000000r 1               
000000r 1               DARK_TURQUOISE = $0c
000000r 1               MEDIUM_TURQUOISE = $1c
000000r 1               LIGHT_TURQUOISE = $2c
000000r 1               LIGHTEST_TURQUOISE = $3c
000000r 1               
000000r 1               BLACK = $0f
000000r 1               DARKEST_GRAY = $2d
000000r 1               MEDIUM_GRAY2 = $3d
000000r 1               
000000r 1               
000000r 1               ;Posicion fija del hongo
000000r 1               HONGOX = 64
000000r 1               HONGOY = 76
000000r 1               
000000r 1               ;Indices de las notas musicales
000000r 1               NC4 = 0
000000r 1               NC4b= 1
000000r 1               ND4 = 2
000000r 1               ND4b= 3
000000r 1               NE4 = 4
000000r 1               NF4 = 5
000000r 1               NF4b= 6
000000r 1               NG4 = 7
000000r 1               NG4b= 8
000000r 1               NA4 = 9
000000r 1               NA4b= 10
000000r 1               NB4 = 11
000000r 1               
000000r 1               NC5 = 12
000000r 1               NC5b= 13
000000r 1               ND5 = 14
000000r 1               ND5b= 15
000000r 1               NE5 = 16
000000r 1               NF5 = 17
000000r 1               NF5b= 18
000000r 1               NG5 = 19
000000r 1               NG5b= 20
000000r 1               NA5 = 21
000000r 1               NA5b= 22
000000r 1               NB5 = 23
000000r 1               
000000r 1               SIL = 24
000000r 1               
000000r 1               ;Definir el segmento HEADER para que FCEUX reconozca el archivo .nes
000000r 1               ;como una imagen valida de un cartucho de NES
000000r 1               
000000r 1               .segment "HEADER"
000000r 1               
000000r 1               ; Configurar con Mapper NROM 0 con bancos fijos
000000r 1  4E 45 53 1A    .byte 'N', 'E', 'S', $1A    ; Firma de NES para el emulador
000004r 1  02             .byte $02                   ; PRG tiene 16k
000005r 1  01             .byte $01                   ; CHR tiene 8k (usar mario.chr)
000006r 1  00             .byte %00000000             ;NROM Mapper 0
000007r 1  00 00 00 00    .byte $0, $0, $0, $0, $0, $0
00000Br 1  00 00        
00000Dr 1               ; Fin del header
00000Dr 1               ;; Este Header se encuentra definido en el archivo link.x el cual
00000Dr 1               ;; define donde va a quedar en el archivo .NES final
00000Dr 1               
00000Dr 1               
00000Dr 1               ;Incluir el binario con las imagenes de la rom de caracteres
00000Dr 1               .segment "IMG"
000000r 1  03 0F 1F 1F  .incbin "mario.chr"
000004r 1  1C 24 26 66  
000008r 1  00 00 00 00  
002000r 1               
002000r 1               ;Declaracion de variables en la pagina 0
002000r 1               ;; Esto es RWM (RAM), por ende se "reservan" bytes
002000r 1               ;; para luego ser usados como variables.
002000r 1               .segment "ZEROPAGE"
000000r 1                   ;;MarioOffsetX,Y guardan la posicion de mario UL.
000000r 1  xx               MarioOffsetX: 		.res 1
000001r 1  xx               MarioOffsetY: 		.res 1
000002r 1                   ;Mario ocupa 4 sprites (UL,UR,LL,LR) solo guardamos
000002r 1                   ;el punto UL (arriba izquierda) ya que el resto se
000002r 1                   ;calcula en base a este unico punto
000002r 1               
000002r 1                   ;;MarioEstadoSalto guarda el estado del salto.
000002r 1                   ;;  %00000000=No esta saltando
000002r 1                   ;;  %10000000=Comenzo a saltar
000002r 1                   ;;  %10xxxxxx=Estado salto ascendente
000002r 1                   ;;  %01xxxxxx=Cayendo por gravedad
000002r 1  xx               MarioEstadoSalto:  	.res 1
000003r 1               
000003r 1                   ;;MarioEstadoSprite indica que dibujo le corresponde
000003r 1                   ;; 00 -> Moviendose derecha etapa 0 (manos separadas)
000003r 1               	;; 01 -> Moviendose derecha etapa 1 (manos juntas)
000003r 1               	;; 02 -> Moviendose derecha etapa 2 (mano adelante)
000003r 1               	;; 03 -> Moviendose derecha etapa 3 (manos juntas)
000003r 1               	;; 04 -> Quieto mirando derecha
000003r 1               	;; 05 -> Salto
000003r 1               	;; 06 -> Caida
000003r 1               
000003r 1               	;; 80 -> Moviendose izquierda etapa 1 (manos separadas)
000003r 1               	;; 81 -> Moviendose izquierda etapa 2 (manos juntas)
000003r 1               	;; 82 -> Moviendose izquierda etapa 3 (mano adelante)
000003r 1               	;; 83 -> Moviendose izquierda etapa 2 (manos juntas)
000003r 1               	;; 84 -> Quieto mirando izquierda
000003r 1               	;; 85 -> Salto izquierda
000003r 1               	;; 86 -> Caida izquierda
000003r 1  xx               MarioEstadoSprite: 		.res 1
000004r 1                   ;;MarioEstadoSpritedb es un puntero de 16 bits a memoria ROM
000004r 1                   ;;para recorrer la tabla con los sprites correspondientes
000004r 1                   ;;a los estados de mario. Se necesitan 16 bits para apuntar
000004r 1                   ;;en modo indirecto indexado (MarioEstadoSpritedb),y.
000004r 1  xx xx            MarioEstadoSpritedb:	.res 2
000006r 1               
000006r 1                   ;;MarioUltimoLado indica para que lado quedo mirando mario
000006r 1                   ;; 0 --> derecha , 1 --> izquierda
000006r 1  xx               MarioUltimoLado:	.res 1
000007r 1                   ;Esto se actualiza cada vez que se aprieta un boton LEFT o RIGHT
000007r 1                   ;del Joystick. Right resetea el bit y Left setea el bit menos sig.
000007r 1               
000007r 1                   ;;JoystickPress ; Indica que boton se apreto en el joystick
000007r 1                   ;; %UP DOWN LEFT RIGHT START SELECT A B: 1=apretado, 0=no apretado
000007r 1  xx               JoystickPress:		.res 1
000008r 1               
000008r 1                   ;;Variables usadas para encontrar posiciones
000008r 1  xx xx            NameTablePointer:  	.res 2 ;Puntero a nametable
00000Ar 1                   ;Se usa para el modo de direccionamiento indexado indirecto
00000Ar 1                   ;de forma de recorrer un Nametable de 960 bytes apuntando
00000Ar 1                   ;con (NameTablePointer),Y.
00000Ar 1               
00000Ar 1                   ;;Variables de Tile. Se usan para ubicar un Tile en pantalla usando
00000Ar 1                   ;;las coordenadas de pantalla (x,y) reales.
00000Ar 1  xx               FindTileX:    .res 1
00000Br 1  xx               FindTileY:    .res 1
00000Cr 1                   ;Tanto FindTileX e Y se cargan con coordenadas X,Y reales de
00000Cr 1                   ;pantalla (ej: posicion de un sprite) y se usan para encontrar
00000Cr 1                   ;en un Nametable cual es el valor para el tile correspondiente
00000Cr 1                   ;a la posicion X,Y.
00000Cr 1  xx               TileCount:    .res 1
00000Dr 1                   ;TileCount se usa para contar tiles que generalmente respetan un
00000Dr 1                   ;cierto patron, ej: menor a $3F quiere decir que es transparente,
00000Dr 1                   ;por ejemplo nubes o arbustos o elementos que mario pasa por
00000Dr 1                   ;adelante sin chocar. A diferencia de bloques, nubes solidas,etc.
00000Dr 1               
00000Dr 1                   ;;Variable para contar los puntos.
00000Dr 1  xx               Puntos1:	  .res 1
00000Er 1  xx               Puntos0:      .res 1
00000Fr 1               
00000Fr 1                   ;;Variable FLAG usado para indicar que hubo una NMI y por ende
00000Fr 1                   ;;podemos actualizar la pantalla ya que el NES no la esta dibujando.
00000Fr 1  xx               FlagNMI:      .res 1
000010r 1               
000010r 1                   ;;Contador de Frames (NMIs) que sirve para contar tiempo real
000010r 1  xx               FrameCounter: .res 1
000011r 1               
000011r 1                   ;;Flag para indica que debe dibujarse el hongo
000011r 1  xx               HongoVisible: .res 1
000012r 1               
000012r 1                   ;;Flag usado para indicar que mario choco con el hongo
000012r 1  xx               SpriteChoca:  .res 1
000013r 1               
000013r 1                   ;;Variables usadas para la musica
000013r 1  xx               LSDPlaying:   .res 1
000014r 1                   ;LSDPlaying=1 --> Esta tocando la musica
000014r 1  xx               LSDNote:	  .res 1
000015r 1                   ;Puntero a la nota que se esta reproduciendo
000015r 1  xx               LSDNoteTime:  .res 1
000016r 1                   ;Contador de tiempo para la nota.
000016r 1  xx               LSDSky:       .res 1
000017r 1                   ;Color del cielo usado en el primer byte de la paleta de colores
000017r 1                   ;para cambiar el color del cielo cuando mario escucha LSD.
000017r 1               
000017r 1                   ;;Variable usada para saber que color tienen los elementos que
000017r 1                   ;;hacen blink
000017r 1  xx               PaletteBlink: .res 1
000018r 1               
000018r 1                   ;;Variable speed indica que mario se mueve mas rapido por boton B
000018r 1  xx               MarioSpeed:   .res 1
000019r 1               
000019r 1               
000019r 1               
000019r 1               ;;Segmento de codigo guardado en la ROM
000019r 1               .segment "CODE"
000000r 1               
000000r 1               ;Rutina de interrupcion (IRQ)
000000r 1               ;No es utilizada por ahora
000000r 1               irq:
000000r 1  40           	rti
000001r 1               
000001r 1               ;;Rutina de interrupcion (Reset)
000001r 1               ;;; Esta rutina se dispara cuando el nintendo se enciende
000001r 1               ;;; o se aprieta el boton de reset. Se encarga de inicializar
000001r 1               ;;; el hardware
000001r 1               reset:
000001r 1  78             SEI          ; desactivar IRQs
000002r 1  D8             CLD          ; desactivar modo decimal
000003r 1               
000003r 1                 ;;Durante el encendido del Nintendo hay que respetar unos tiempos
000003r 1                 ;;hasta que el PPU se encuentra listo para ser utilizado.
000003r 1                 ;;A continuacion se siguen los pasos sugeridos en:
000003r 1                 ;; https://wiki.nesdev.com/w/index.php/Init_code
000003r 1  A2 40          LDX #$40
000005r 1  8E 17 40       STX $4017    ; disable APU frame IRQ
000008r 1  A2 FF          LDX #$FF
00000Ar 1  9A             TXS          ; Set up stack
00000Br 1  E8             INX          ; now X = 0
00000Cr 1  8E 00 20       STX $2000    ; disable NMI
00000Fr 1  8E 01 20       STX $2001    ; disable rendering
000012r 1  8E 10 40       STX $4010    ; disable DMC IRQs
000015r 1               
000015r 1               vblankwait1:       ; First wait for vblank to make sure PPU is ready
000015r 1  2C 02 20       BIT $2002
000018r 1  10 FB          BPL vblankwait1
00001Ar 1               
00001Ar 1               clrmem:
00001Ar 1  A9 00          LDA #$00
00001Cr 1  95 00          STA $0000, x
00001Er 1  9D 00 01       STA $0100, x
000021r 1  9D 00 03       STA $0300, x
000024r 1  9D 00 04       STA $0400, x
000027r 1  9D 00 05       STA $0500, x
00002Ar 1  9D 00 06       STA $0600, x
00002Dr 1  9D 00 07       STA $0700, x
000030r 1  A9 FE          LDA #$FE
000032r 1  9D 00 02       STA $0200, x
000035r 1  E8             INX
000036r 1  D0 E2          BNE clrmem
000038r 1               
000038r 1               vblankwait2:      ; Second wait for vblank, PPU is ready after this
000038r 1  2C 02 20       BIT $2002
00003Br 1  10 FB          BPL vblankwait2
00003Dr 1               
00003Dr 1               ;; Cargamos las paletas de color del fondo y de los sprites.
00003Dr 1               ;; Codigo adaptado para CC65 tomado de:
00003Dr 1               ;; https://gist.github.com/camsaul/0bd13b94574d936ce9a7
00003Dr 1               
00003Dr 1               LoadPalettes:
00003Dr 1  AD 02 20       LDA $2002     ; read PPU status to reset the high/low latch to high
000040r 1  A9 3F          LDA #$3F
000042r 1  8D 06 20       STA $2006     ; write the high byte of $3F10 address
000045r 1  A9 00          LDA #$00
000047r 1  8D 06 20       STA $2006     ; write the low byte of $3F10 address
00004Ar 1               
00004Ar 1                 ;; Load the palette data
00004Ar 1  A2 00          LDX #$00
00004Cr 1               LoadPalettesLoop:
00004Cr 1  BD rr rr       LDA NewWorldPalette, x;load data from address (PaletteData + x)
00004Fr 1  8D 07 20       STA $2007             ; write to PPU
000052r 1  E8             INX                   ; (inc X)
000053r 1  E0 20          CPX #$20              ; Compare X to $20 (decimal 32)
000055r 1  D0 F5          BNE LoadPalettesLoop  ; (when (not= x 32) (recur))
000057r 1               
000057r 1                 ;;Inicializamos las variables Puntos ya que se van a dibujar
000057r 1                 ;;ahora que cargamos el fondo.
000057r 1  A9 00          LDA #$00
000059r 1  85 rr          STA Puntos1
00005Br 1  A9 00          LDA #$00
00005Dr 1  85 rr          STA Puntos0
00005Fr 1  A9 00          LDA #$00
000061r 1  85 rr          STA PaletteBlink
000063r 1               
000063r 1                 ;; Ahora que las paletas estan cargadas, podemos dibujar el fondo
000063r 1  20 rr rr       JSR SUBDibujaFondo
000066r 1               
000066r 1                 ;; Encendemos el PPU
000066r 1                 ;; y el barrido vertical
000066r 1                 ;; y apuntamos el PPU a
000066r 1                 ;; la tabla 0 de sprites
000066r 1                 ;; y 1 para fondos
000066r 1               
000066r 1  A9 90          LDA #%10010000
000068r 1  8D 00 20       STA $2000
00006Br 1               
00006Br 1                 ;; Encendemos Sprites, Background y sin clipping en lado izquierdo
00006Br 1  A9 1E          LDA #%00011110
00006Dr 1  8D 01 20       STA $2001
000070r 1               
000070r 1                 ;;Apagamos el scroll del background (fondo)
000070r 1  A9 00          LDA #$00
000072r 1  8D 05 20       STA $2005
000075r 1  8D 05 20       STA $2005
000078r 1               
000078r 1                 ;;Habilitamos las interrupciones
000078r 1  58             CLI
000079r 1               
000079r 1                 ;;Prendemos audio
000079r 1                 ;;  Solo canal Pulse 1 (primer canal onda cuadrada)
000079r 1  A9 01           lda #%00000001
00007Br 1  8D 15 40        sta $4015
00007Er 1               
00007Er 1                 ;;Inicializamos las variables
00007Er 1                 ;;Le damos un offset inicial a mario en X e Y
00007Er 1  A9 C0          LDA  #$C0
000080r 1  85 rr          STA  MarioOffsetY
000082r 1  A9 20          LDA #$20
000084r 1  85 rr          STA MarioOffsetX
000086r 1                 ;;Cielo color azul al principio
000086r 1  A9 21          LDA #$21
000088r 1  85 rr          STA LSDSky
00008Ar 1                 ;;Arranca mirando a la izquierda
00008Ar 1  A9 01          LDA #$01
00008Cr 1  85 rr          STA MarioUltimoLado
00008Er 1  A9 80          LDA #$80
000090r 1  85 rr          STA MarioEstadoSprite
000092r 1                 ;;No arranca saltando
000092r 1  A9 00          LDA #$00
000094r 1  85 rr          STA MarioEstadoSalto
000096r 1               
000096r 1                 ;;Ponemos en cero otras variables
000096r 1  85 rr          STA FrameCounter
000098r 1  85 rr          STA HongoVisible
00009Ar 1  85 rr          STA LSDPlaying
00009Cr 1  85 rr          STA LSDNote
00009Er 1  85 rr          STA LSDNoteTime
0000A0r 1  85 rr          STA MarioSpeed
0000A2r 1               
0000A2r 1               
0000A2r 1                 ;;Aqui termina la runtina de reset.. el codigo va a quedar ciclando
0000A2r 1                 ;;en la siguiente posicion. Dado que solo se puede refrezcar la
0000A2r 1                 ;;pantalla cuando no se esta dibujando.. usamos el FlagNMI para
0000A2r 1                 ;;indicar cuando es seguro refrezcar la pantalla.
0000A2r 1               FIN:
0000A2r 1  A5 rr        	LDA FlagNMI
0000A4r 1  F0 FC        	BEQ FIN ;;Queda loopeando mientras FlagNMI=0
0000A6r 1  A9 00        	LDA #$0
0000A8r 1  85 rr        	STA FlagNMI
0000AAr 1               	;;Ahora es seguro escribir cosas en la memoria de la pantalla
0000AAr 1               
0000AAr 1               	;;Empezamos controlando la musica
0000AAr 1  20 rr rr     	JSR SUBPlayLSD
0000ADr 1               	;;Llevamos la cuenta de los frame en FrameCounter
0000ADr 1               	;;Se resetea cada 50 frames (1 segundo)
0000ADr 1  E6 rr        	inc FrameCounter
0000AFr 1  A5 rr        	LDA FrameCounter
0000B1r 1  29 07        	AND #%00000111
0000B3r 1  C9 07        	CMP #%00000111
0000B5r 1  D0 03        	BNE incSeg
0000B7r 1  20 rr rr     	JSR SUBBlinkPalette
0000BAr 1               
0000BAr 1               incSeg:
0000BAr 1  A5 rr        	LDA FrameCounter
0000BCr 1  C9 32        	CMP #50
0000BEr 1  D0 04        	BNE sigueMain
0000C0r 1  A9 00        	LDA #0
0000C2r 1  85 rr        	STA FrameCounter
0000C4r 1               sigueMain:
0000C4r 1                   ;;Dibujamos los tiles de SCORE en caso que hayan cambiado
0000C4r 1  20 rr rr     	JSR SUBActualizaScore
0000C7r 1               
0000C7r 1                 ;Dado que en $0200~$02ff tenemos cargados los sprites
0000C7r 1                 ;Utilizamos el DMA para transferir estos 256 bytes a memoria
0000C7r 1                 ;de video en la ubicacion de los sprites.
0000C7r 1  A9 00          LDA #$00
0000C9r 1  8D 03 20       STA $2003  ; cargamos en el DMA la parte baja de 0200
0000CCr 1  A9 02          LDA #$02
0000CEr 1  8D 14 40       STA $4014  ; cargamos en el DMA la parte alta de 0200 y comienza.
0000D1r 1                 ;Esto deberia bloquear el procesador hasta que termina.
0000D1r 1               
0000D1r 1                 ;;Leemos el joystick. Esto actualiza la variable JoystickPress
0000D1r 1  20 rr rr       JSR SUBReadJoy
0000D4r 1               
0000D4r 1                 ;;Actualizamos la posicion de mario
0000D4r 1  A5 rr          LDA JoystickPress
0000D6r 1  29 01          AND #BUTTON_RIGHT
0000D8r 1  F0 13          BEQ noRight
0000DAr 1                 ;; Se apreto el boton derecho
0000DAr 1  A9 00          LDA #$00
0000DCr 1  85 rr          STA MarioUltimoLado ;;Actualizamos el lado que mira mario
0000DEr 1                 ;;Verificamos si a la derecha hay algo
0000DEr 1  20 rr rr       JSR SUBVerificarCostado
0000E1r 1                 ;;Si el resultado da 0, entonces es seguro mover, sino no
0000E1r 1  D0 0A          BNE noRight
0000E3r 1  E6 rr          INC MarioOffsetX
0000E5r 1  A5 rr          LDA MarioSpeed
0000E7r 1  C9 02          CMP #2
0000E9r 1  D0 02          BNE noRight
0000EBr 1  E6 rr          INC MarioOffsetX
0000EDr 1               
0000EDr 1               noRight:
0000EDr 1                 ;; Verificamos si apreto  a la izquierda
0000EDr 1  A5 rr          LDA JoystickPress
0000EFr 1  29 02          AND #BUTTON_LEFT
0000F1r 1  F0 13          BEQ noLeft
0000F3r 1  A9 01          LDA #$01
0000F5r 1  85 rr          STA MarioUltimoLado ;;Actualizamos el lado que mira mario
0000F7r 1                 ;;Verificamos si a la izquierda hay algo
0000F7r 1  20 rr rr       JSR SUBVerificarCostado
0000FAr 1                 ;;Si el resultado da 0, entonces es seguro mover, sino no
0000FAr 1  D0 0A          BNE noLeft
0000FCr 1  C6 rr          DEC MarioOffsetX
0000FEr 1  A5 rr          LDA MarioSpeed
000100r 1  C9 02          CMP #2
000102r 1  D0 02          BNE noLeft
000104r 1  C6 rr          DEC MarioOffsetX
000106r 1               
000106r 1               noLeft:
000106r 1                 ;;Vemos si apreto el boton A
000106r 1  A5 rr          LDA JoystickPress
000108r 1  29 80          AND #BUTTON_A
00010Ar 1  F0 10          BEQ noButtonA
00010Cr 1                 ;;Si se apreto A, hay que verificar si no esta saltando
00010Cr 1  A5 rr          LDA MarioEstadoSalto
00010Er 1  29 80          AND #%10000000
000110r 1  D0 18          BNE finBotonesCheck ;; si Acc=0 no estaba saltando
000112r 1                 ;;Hay que ver que no este cayendo por gravedad
000112r 1  A5 rr          LDA MarioEstadoSalto
000114r 1  29 40          AND #%01000000
000116r 1  D0 12          BNE finBotonesCheck
000118r 1                 ;;Como no estaba saltando ni cayendo por gravedad entonces
000118r 1                 ;;Ponemos 1 en el bit mas significativo de MarioEstadoSalto
000118r 1                 ;;Para indicar que tiene que saltar
000118r 1  A9 80          LDA #%10000000
00011Ar 1  85 rr          STA MarioEstadoSalto
00011Cr 1               noButtonA:
00011Cr 1  A9 01          LDA #$01
00011Er 1  85 rr          STA MarioSpeed
000120r 1  A5 rr          LDA JoystickPress
000122r 1  29 40          AND #BUTTON_B
000124r 1  F0 04          BEQ noButtonB
000126r 1  A9 02          LDA #$02
000128r 1  85 rr          STA MarioSpeed
00012Ar 1               
00012Ar 1               noButtonB:
00012Ar 1                 ;;Aqui deberiamos verificar el boton B si se usara para algo
00012Ar 1               finBotonesCheck:
00012Ar 1               
00012Ar 1               ;;;;
00012Ar 1               ;; Ahora que se actualizaron los offset de X,Y de mario
00012Ar 1               ;; podemos llamar a la funcion que actualiza el sprite
00012Ar 1  20 rr rr       JSR SUBDibujaMario
00012Dr 1               
00012Dr 1                 ;;Ahora que se actualizo la posicion de mario en pantalla
00012Dr 1                 ;;Podemos terminar y volver al loop principal a esperar
00012Dr 1                 ;;otro refrezco de pantalla.
00012Dr 1  4C rr rr       JMP FIN
000130r 1               
000130r 1               ;Rutina de interrupcion (NMI)
000130r 1               ;Esta rutina se dispara cuando la pantalla
000130r 1               ;se dibujo por completo, y el barrido vertical
000130r 1               ;esta volviendo al inicio. Deberia poder utilizarse
000130r 1               ;solo por 2250 ciclos aprox. Deberia dispararse 25 veces
000130r 1               ;por segundo o 50 con interlaceado
000130r 1               nmi:
000130r 1                 ;;Guardamos en el stack el estado del CPU (flags y acumulador)
000130r 1  48             PHA
000131r 1  08             PHP
000132r 1                 ;;Incrementamos el flag NMI que deberia pasar de 0 a 1
000132r 1  E6 rr          INC FlagNMI
000134r 1                 ;;Ahora recuperamos el estado del CPU (flags y acumulador) y listo
000134r 1  28             PLP
000135r 1  68             PLA
000136r 1  40             RTI
000137r 1               
000137r 1               
000137r 1               ;;Aqui comienzan las subrutinas auxiliares
000137r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000137r 1               
000137r 1               SUBBlinkPalette:
000137r 1               
000137r 1  AD 02 20         LDA $2002     ; read PPU status to reset the high/low latch to high
00013Ar 1  A9 3F        	LDA #$3F
00013Cr 1  8D 06 20     	STA $2006     ; write the high byte of $3F10 address
00013Fr 1  A9 00        	LDA #$00
000141r 1  8D 06 20     	STA $2006     ; write the low byte of $3F10 address
000144r 1  A5 rr        	LDA LSDSky
000146r 1  8D 07 20     	STA $2007
000149r 1               
000149r 1                 ;;Si la paleta es $16 pasar a $25, si es $25 pasar
000149r 1  A5 rr        	LDA PaletteBlink
00014Br 1  C9 01        	CMP #$01
00014Dr 1  30 10        	BMI Paleta1
00014Fr 1  C9 02        	CMP #$02
000151r 1  30 14        	BMI Paleta2
000153r 1  C9 04        	CMP #$04
000155r 1  30 18        	BMI Paleta3
000157r 1  C9 07        	CMP #$07
000159r 1  30 1C        	BMI Paleta4
00015Br 1  A9 00        	LDA #00
00015Dr 1  85 rr        	STA PaletteBlink
00015Fr 1               
00015Fr 1               Paleta1:
00015Fr 1  A9 05        	LDA #$05
000161r 1  8D 07 20     	STA $2007
000164r 1  4C rr rr     	JMP finBlinkPalette
000167r 1               
000167r 1               Paleta2:
000167r 1  A9 16        	LDA #$16
000169r 1  8D 07 20     	STA $2007
00016Cr 1  4C rr rr     	JMP finBlinkPalette
00016Fr 1               
00016Fr 1               Paleta3:
00016Fr 1  A9 27        	LDA #$27
000171r 1  8D 07 20     	STA $2007
000174r 1  4C rr rr     	JMP finBlinkPalette
000177r 1               
000177r 1               Paleta4:
000177r 1  A9 37        	LDA #$37
000179r 1  8D 07 20     	STA $2007
00017Cr 1               
00017Cr 1               finBlinkPalette:
00017Cr 1  E6 rr           INC PaletteBlink
00017Er 1  60              RTS
00017Fr 1               
00017Fr 1               
00017Fr 1               ;;Esta subrutina actualiza el byte de la paleta que define el fondo
00017Fr 1               ;;para poder cambiar el color del cielo cuando mario se come el hongo.
00017Fr 1               SUBChangeSky:
00017Fr 1  AD 02 20       LDA $2002       ;Se resetea el puerto del PPU para poder escribirlo
000182r 1  A9 3F          LDA #$3F
000184r 1  8D 06 20       STA $2006       ;Cargamos la parte alta de la direccion $3F00
000187r 1  A9 00          LDA #$00
000189r 1  8D 06 20       STA $2006       ;Cargamos la parte baja de la direccion $3F00
00018Cr 1               
00018Cr 1  A5 rr          LDA LSDSky      ;Cargamos en el acumulador el valor para el cielo
00018Er 1  8D 07 20       STA $2007       ;Forzamos el valor en el PPU apuntando a $3F00
000191r 1               				  ;; Este valor comienza la paleta, y la primer posicion
000191r 1               				  ;; indica el color del background.
000191r 1  60             RTS
000192r 1               
000192r 1               ;;Esta rutina actualiza los tiles hasta el tile de score que cambia
000192r 1               ;;constantemente, por ende lo tenemos que actualizar.
000192r 1               SUBActualizaScore:
000192r 1  AD 02 20       LDA $2002             ; Hay que leer el PPU para resetear la direccion
000195r 1  A9 20          LDA #$20
000197r 1  8D 06 20       STA $2006             ; Se carga la parte alta de $2000
00019Ar 1  A9 00          LDA #$00
00019Cr 1  8D 06 20       STA $2006             ; Se carga la parte baja de $2000
00019Fr 1  A2 00          LDX #$00              ;
0001A1r 1               
0001A1r 1               
0001A1r 1                 ;;El SCORE se muestra en las posiciones $65 y $66 asi que cargamos
0001A1r 1                 ;;el mapa hasta esas posiciones y luego cargamos a mano el score
0001A1r 1               LoadBackgroundLoopScore:
0001A1r 1  BD rr rr       LDA NewWorld, x
0001A4r 1  8D 07 20       STA $2007
0001A7r 1  E8             INX
0001A8r 1  E0 65          CPX #$65  ;;Mientras no cargue $65 que siga
0001AAr 1  D0 F5          BNE LoadBackgroundLoopScore
0001ACr 1                  ;;Ahora que cargo los primeros $65 tiles, viene el score
0001ACr 1  A5 rr          LDA Puntos1
0001AEr 1  8D 07 20       STA $2007
0001B1r 1  A5 rr          LDA Puntos0
0001B3r 1  8D 07 20       STA $2007
0001B6r 1                 ;;Listo
0001B6r 1  60             RTS
0001B7r 1               
0001B7r 1               ;;Grabamos la cancion LSD (Lucy in the Sky with Diamonds)
0001B7r 1               LSD:
0001B7r 1  04 0C 09 0C      .byte NE4, 12, NA4, 12, NE5, 12, NG4, 12, NE5, 12, NA4, 12, NF4b, 12,NA4, 12, NE5, 12, NF4, 10, ND5, 8, NC5b,8, NA4, 8  ,$FF
0001BBr 1  10 0C 07 0C  
0001BFr 1  10 0C 09 0C  
0001D2r 1               
0001D2r 1               ;;Esta subrutina reproduce nota a nota la cancion LSD
0001D2r 1               SUBPlayLSD:
0001D2r 1  48               PHA
0001D3r 1                   ;;Primero vemos si la cancion esta activa
0001D3r 1  A5 rr            LDA LSDPlaying
0001D5r 1  F0 52            BEQ finPlayLSD ;;No esta sonando
0001D7r 1                   ;;Si esta sonando, tenemos que verificar que el tiempo de nota
0001D7r 1                   ;;no haya llegando a cero
0001D7r 1  A5 rr            LDA LSDNoteTime
0001D9r 1                   ;;Si no es cero, entonces lo dejamos
0001D9r 1  D0 32            BNE decNota
0001DBr 1                   ;;Si el tiempo de nota es cero, avanzamos a la siguiente nota
0001DBr 1  A9 BF            LDA #%10111111 ;;Configuramos el Pulse1 para que toque constante
0001DDr 1  8D 00 40     	STA $4000	   ;;a maximo volumen
0001E0r 1               
0001E0r 1                   ;;Buscamos la nota que hay que tocar
0001E0r 1  A6 rr            LDX LSDNote ;; Esta variable apunta a LSD
0001E2r 1  BD rr rr         LDA LSD,x ;; Carga el elemento X del vector LSD
0001E5r 1  C9 FF            CMP #$FF ;;Si es el ultimo apago la musica
0001E7r 1  F0 28            BEQ apagaLSD
0001E9r 1                   ;;Si no es la ultima nota, la buscamos en NOTAS
0001E9r 1  AA               TAX ;;El indice para buscar en el vector notas esta en A, lo
0001EAr 1               		;;pasamos a X para usarlo en modo indexado
0001EAr 1  BD rr rr         LDA NOTAS,x ;Ahora buscamos NOTAS[x] siendo X el LSDNote
0001EDr 1  8D 02 40         STA $4002
0001F0r 1                   ;;Las primeras 8 notas requieren un 1 en $4003, pero el resto no
0001F0r 1  A9 00            LDA #0 ;;Cargamos un 0 originalmente y le sumamos 1 si hace falta
0001F2r 1  E0 08            CPX #8
0001F4r 1  10 02            BPL altaCero ;;Si  la nota es mayor a 8, dejamos el 0
0001F6r 1  A9 01            LDA #1 ;;Sino ponemos un 1
0001F8r 1               altaCero:
0001F8r 1  8D 03 40     	STA $4003 ;;Guardamos la parte alta que puede ser 0 o 1.
0001FBr 1                   ;;Cargamos ahora el tiempo que debe durar la nota
0001FBr 1  E6 rr            INC LSDNote
0001FDr 1  A6 rr            LDX LSDNote
0001FFr 1  BD rr rr         LDA LSD,x
000202r 1  85 rr            STA LSDNoteTime
000204r 1                   ;;Apuntamos a la siguiente nota
000204r 1  E6 rr            INC LSDNote
000206r 1                   ;;Cambiamos el color del cielo
000206r 1  E6 rr            INC LSDSky
000208r 1  20 rr rr         JSR SUBChangeSky
00020Br 1                   ;;Restauramos A y volvemos
00020Br 1  68               PLA
00020Cr 1  60               RTS
00020Dr 1               ;; Si el tiempo nota no llego a 0, decrementamos el tiempo y salimos
00020Dr 1               decNota:
00020Dr 1  C6 rr        	DEC LSDNoteTime
00020Fr 1  68           	PLA
000210r 1  60           	RTS
000211r 1               ;; Si tenemos que apagar la musica, ponemos 0 en PULSE1 en PPU
000211r 1               apagaLSD:
000211r 1  A9 00        	LDA #0
000213r 1  8D 00 40     	STA $4000
000216r 1  8D 02 40     	STA $4002
000219r 1  8D 03 40     	STA $4003
00021Cr 1               	;;Reseteamos el tiempo de nota a 0 y apuntamos el vector de nota
00021Cr 1               	;;a la primer nota y apagamos la musica.
00021Cr 1  85 rr        	STA LSDNoteTime
00021Er 1  85 rr        	STA LSDNote
000220r 1  85 rr        	STA LSDPlaying
000222r 1               	;;Restauramos el cielo al color normal.
000222r 1  A9 21        	LDA #$21
000224r 1  85 rr        	STA LSDSky
000226r 1  20 rr rr     	JSR SUBChangeSky
000229r 1                   ;;Se termino
000229r 1               finPlayLSD:
000229r 1  68               PLA
00022Ar 1  60           	RTS
00022Br 1               
00022Br 1               
00022Br 1               ;;Esta subrutina incrementa el score en 1. Pero como se muestra en dos
00022Br 1               ;;digitos entonces hay que incrementar el primero y luego el segundo
00022Br 1               ;;dependiendo del valor del primer digito
00022Br 1               SUBIncrementarScore:
00022Br 1  E6 rr            INC Puntos0
00022Dr 1  A5 rr            LDA Puntos0
00022Fr 1  C9 0A            CMP #10
000231r 1  F0 01            BEQ overPuntos0
000233r 1  60               RTS
000234r 1               overPuntos0:
000234r 1  A9 00        	LDA #0
000236r 1  85 rr        	STA Puntos0
000238r 1  E6 rr        	INC Puntos1
00023Ar 1  A5 rr        	LDA Puntos1
00023Cr 1  C9 0A        	CMP #10
00023Er 1  F0 01        	BEQ overPuntos1
000240r 1  60           	RTS
000241r 1               overPuntos1:
000241r 1  A9 00        	LDA #0
000243r 1  85 rr        	STA Puntos1
000245r 1  85 rr            STA Puntos0
000247r 1  60               RTS
000248r 1               
000248r 1               
000248r 1               SUBVerificarCostado:
000248r 1               	;;Esta subrutina verifica si mario se puede mover hacia un costado
000248r 1               	;;Dependiendo si se apreto derecha o izquierda
000248r 1               	;;Si el acumulador tiene 0, verifica derecha
000248r 1               	;;Si el acumulador tiene 1 , verifica izquierda
000248r 1  F0 12        	BEQ verificaDerecha
00024Ar 1               	;;Limpiamos TileCount para contar colisiones
00024Ar 1  A9 00        	LDA #$00
00024Cr 1  85 rr        	STA TileCount
00024Er 1               	;;Para verificar a la izquierda, tenemos que ver si hay un tile
00024Er 1               	;;en MarioOffsetX-1 con ambos MarioOffsetY y MarioOffsetY
00024Er 1  A5 rr        	LDA MarioOffsetX
000250r 1  18           	CLC
000251r 1  E5 rr        	SBC MarioSpeed
000253r 1  85 rr        	STA FindTileX
000255r 1  A5 rr        	LDA MarioOffsetY
000257r 1  85 rr        	STA FindTileY
000259r 1  4C rr rr     	JMP detectarColision
00025Cr 1               
00025Cr 1               verificaDerecha:
00025Cr 1  A9 00            LDA #$00
00025Er 1  85 rr            STA TileCount
000260r 1  A5 rr            LDA MarioOffsetX
000262r 1  18               CLC
000263r 1  69 10            ADC #16
000265r 1  65 rr            ADC MarioSpeed
000267r 1  85 rr            STA FindTileX
000269r 1  A5 rr            LDA MarioOffsetY
00026Br 1  85 rr            STA FindTileY
00026Dr 1               
00026Dr 1               detectarColision:
00026Dr 1                   ;;Ahora FindTileX y FindTileY tienen el primer punto a comparar
00026Dr 1  20 rr rr         JSR SUBFindTile
000270r 1                   ;;Si dio mayor a $3F entonces hay colision
000270r 1  C9 3F            CMP #$3F
000272r 1  30 02            BMI noHayColisionUno
000274r 1  E6 rr            INC TileCount
000276r 1               noHayColisionUno:
000276r 1  18               CLC
000277r 1  A5 rr            LDA FindTileY
000279r 1  69 10            ADC #16
00027Br 1  85 rr            STA FindTileY
00027Dr 1  20 rr rr         JSR SUBFindTile
000280r 1  C9 3F            CMP #$3F
000282r 1  30 02            BMI noHayColisionDos
000284r 1  E6 rr            INC TileCount
000286r 1               noHayColisionDos:
000286r 1  A5 rr        	LDA TileCount
000288r 1               	;; si TileCount es 0 entonces no hay colision
000288r 1               	;; Si es mayor a 0 entonces hay colision
000288r 1               	;; Devolvemos esto
000288r 1  60           	RTS
000289r 1               
000289r 1               ;;Rutina para leer el registro del Joystick tomada de
000289r 1               ;; https://wiki.nesdev.com/w/index.php/Controller_reading_code
000289r 1               SUBReadJoy:
000289r 1  A9 01            lda #$01
00028Br 1                   ; While the strobe bit is set, buttons will be continuously reloaded.
00028Br 1                   ; This means that reading from JOYPAD1 will only return the state of the
00028Br 1                   ; first button: button A.
00028Br 1  8D 16 40         sta JOYPAD1
00028Er 1  85 rr            sta JoystickPress
000290r 1  4A               lsr a        ; now A is 0
000291r 1                   ; By storing 0 into JOYPAD1, the strobe bit is cleared and the reloading stops.
000291r 1                   ; This allows all 8 buttons (newly reloaded) to be read from JOYPAD1.
000291r 1  8D 16 40         sta JOYPAD1
000294r 1               loop:
000294r 1  AD 16 40         lda JOYPAD1
000297r 1  4A               lsr a	       ; bit 0 -> Carry
000298r 1  26 rr            rol JoystickPress  ; Carry -> bit 0; bit 7 -> Carry
00029Ar 1  90 F8            bcc loop
00029Cr 1  60               rts
00029Dr 1               
00029Dr 1               
00029Dr 1                ;;Esta subrutina busca un TILE en un mapa (NewWorld) usando
00029Dr 1                ;;coordenadas X e Y apuntadas por FindTileX, FindTileY y usa un indice
00029Dr 1                ;;de 2 bytes para recorrer el mapa (NameTablePointer)
00029Dr 1                ;;Codigo tomado de:
00029Dr 1                ;; http://forums.nesdev.com/viewtopic.php?t=19551
00029Dr 1               SUBFindTile:
00029Dr 1  18             clc
00029Er 1                 ;;Dado que buscamos en una matriz de 32x30 donde cada elemento tiene
00029Er 1                 ;; 8x8 pixeles, tenemos que dividir por 8 y multiplicar por 32
00029Er 1                 ;; pero esto es lo mismo que multiplicar por 4, asi que tomamos
00029Er 1                 ;; los 5 bits mas significativos de la posicion Y
00029Er 1  A5 rr          lda FindTileY
0002A0r 1  29 F8          and #%11111000
0002A2r 1               
0002A2r 1                 ;;Y shifteamos a la izquierda dos veces para multiplicar por 4
0002A2r 1  0A             asl
0002A3r 1  26 rr          rol NameTablePointer+1
0002A5r 1  0A             asl
0002A6r 1  26 rr          rol NameTablePointer+1
0002A8r 1                 ;;Y esos valores los guardamos en la parte alta de NameTablePointer
0002A8r 1  18             clc
0002A9r 1  69 rr          adc #<NewWorld ;;Cargamos la parte baja del mapa
0002ABr 1  85 rr          sta NameTablePointer+0
0002ADr 1  A5 rr          lda NameTablePointer+1
0002AFr 1  29 03          and #%00000011
0002B1r 1  69 rr          adc #>NewWorld
0002B3r 1  85 rr          sta NameTablePointer+1 ;;Ahora la parte alta del mapa
0002B5r 1               
0002B5r 1                 ;;Ahora ya avanzamos en el vector de 32x30 tantas filas como tiles
0002B5r 1                 ;;en Y hacian falta, asi que tenemos que dividir la posicion X
0002B5r 1                 ;;en 8 y usar eso como indice
0002B5r 1  18             clc
0002B6r 1  A5 rr          lda FindTileX
0002B8r 1  E9 01          SBC #1
0002BAr 1  4A             lsr
0002BBr 1  4A             lsr
0002BCr 1  4A             lsr
0002BDr 1  A8             tay
0002BEr 1               
0002BEr 1                 ;Ahora NameTablePointer tiene NewWorld avanzando en Y, necesitamos
0002BEr 1                 ;resolver X que ya esta dividido por 8 en el registro Y. Asi que lo
0002BEr 1                 ;usamos como indice apuntando indirecto indexado con NameTablePointer
0002BEr 1  B1 rr          lda (NameTablePointer), y
0002C0r 1                 ;;Listo, en el acumulador quedo el TILE apuntado por FindTileX e Y.
0002C0r 1  60             RTS
0002C1r 1               
0002C1r 1               
0002C1r 1               ;;Esta subrutina se fija si mario tiene algun lugar donde estar apoyado
0002C1r 1               ;;caso contrario lo hace caer por gravedad
0002C1r 1               SUBAplicarGravedad:
0002C1r 1               	;;Verifica si mario no tiene nada debajo de sus pies y debe caer
0002C1r 1               	;; SALVO que este subiendo
0002C1r 1  A9 00        	LDA #$00
0002C3r 1  85 rr        	STA TileCount
0002C5r 1  A5 rr        	LDA MarioEstadoSalto
0002C7r 1  29 80        	AND #%10000000
0002C9r 1  D0 32        	BNE chauGravedad ;; Esta saltando
0002CBr 1               	;; Verificamos que no haya nada debajo en los dos extremos
0002CBr 1               
0002CBr 1  18           	CLC
0002CCr 1  A5 rr        	LDA MarioOffsetY
0002CEr 1  69 12        	ADC #18
0002D0r 1  85 rr        	STA FindTileY
0002D2r 1  A5 rr        	LDA MarioOffsetX
0002D4r 1  85 rr        	STA FindTileX
0002D6r 1  20 rr rr     	JSR SUBFindTile
0002D9r 1               	;;Ahora A tiene el tile a abajo
0002D9r 1  C9 3F        	CMP #$3F
0002DBr 1  10 02        	BPL nadaX
0002DDr 1  E6 rr        	INC TileCount
0002DFr 1               nadaX:
0002DFr 1  18           	CLC
0002E0r 1  A5 rr        	LDA MarioOffsetX
0002E2r 1  69 10        	ADC #16
0002E4r 1  85 rr        	STA FindTileX
0002E6r 1  20 rr rr     	JSR SUBFindTile
0002E9r 1  C9 3F        	CMP #$3F
0002EBr 1  10 02        	BPL finGravedad
0002EDr 1  E6 rr        	INC TileCount
0002EFr 1               
0002EFr 1               finGravedad:
0002EFr 1  A5 rr           LDA TileCount
0002F1r 1  C9 02           CMP #$02
0002F3r 1  D0 08           BNE chauGravedad
0002F5r 1  E6 rr           INC MarioOffsetY
0002F7r 1  E6 rr           INC MarioOffsetY
0002F9r 1  A9 40           LDA #%01000000
0002FBr 1  85 rr           STA MarioEstadoSalto ;;Mario esta cayendo
0002FDr 1               chauGravedad:
0002FDr 1  60              RTS
0002FEr 1               
0002FEr 1               SUBActualizaEstadoMario:
0002FEr 1               	;; Esta subrutina actualiza el estado de mario segun su posicion
0002FEr 1               	;; o si esta saltando o cayendo.
0002FEr 1  A9 00        	LDA #$00
000300r 1  85 rr        	STA MarioEstadoSprite ;;Primero borramos el estado del sprite
000302r 1               
000302r 1               	;;Verificamos a que lado apuntaba mario por ultima vez
000302r 1  A5 rr        	LDA MarioUltimoLado
000304r 1  D0 12        	BNE miraIzquierda
000306r 1               miraDerecha:
000306r 1               	;;Vemos si esta saltando
000306r 1  A5 rr        	LDA MarioEstadoSalto
000308r 1  F0 24        	BEQ estadoSegunPosicion
00030Ar 1               	;;Esta saltando a la derecha
00030Ar 1               	;; Puede que este cayendo
00030Ar 1  29 40        	AND #%01000000
00030Cr 1  D0 05        	BNE cayendoGravedadDerecha
00030Er 1  A9 05        	LDA #$05 ;;Si no cae ni salta y esta quieto, entoces mira derecha
000310r 1  85 rr        	STA MarioEstadoSprite
000312r 1  60           	RTS
000313r 1               cayendoGravedadDerecha:
000313r 1  A9 03            LDA #$03 ;;Si esta cayendo por gravedad, manitos juntas
000315r 1  85 rr            STA MarioEstadoSprite
000317r 1  60               RTS
000318r 1               miraIzquierda:
000318r 1  A5 rr            LDA MarioEstadoSalto
00031Ar 1  F0 0E            BEQ preEstadoSegunPosicion
00031Cr 1                   ;;Puede que este cayendo
00031Cr 1  29 40            AND #%01000000
00031Er 1  D0 05            BNE cayendoGravedadIzquierda
000320r 1  A9 85            LDA #$85 ;;Si no cae ni salta y esta quiero, entonces mira izquierda
000322r 1  85 rr            STA MarioEstadoSprite
000324r 1  60               RTS
000325r 1               cayendoGravedadIzquierda:
000325r 1  A9 83        	LDA #$83 ;; Si esta cayendo por gravedad, manitos juntas
000327r 1  85 rr        	STA MarioEstadoSprite
000329r 1  60           	RTS
00032Ar 1               
00032Ar 1               ;;El estado de mario depende entonces de la posicion en donde esta
00032Ar 1               ;;en pantalla
00032Ar 1               preEstadoSegunPosicion:
00032Ar 1  A9 80            LDA #$80
00032Cr 1  85 rr            STA MarioEstadoSprite ;; Sumo $80 de base ya que es izquierda
00032Er 1               
00032Er 1               estadoSegunPosicion:
00032Er 1               	;; Esta quieto mario?
00032Er 1  A5 rr        	LDA JoystickPress
000330r 1               	;;enmascaro con LeftRight a ver si se mueve
000330r 1  29 03        	AND #%00000011
000332r 1  D0 08        	BNE realPosicion ;;Efectivamente se esta apretando algun boton
000334r 1               				     ;;del joystick asi que vamos al estado basado
000334r 1               				     ;;en la posicion de la pantalla
000334r 1  18           	CLC
000335r 1  A5 rr        	LDA MarioEstadoSprite
000337r 1  69 04        	ADC #$04
000339r 1  85 rr        	STA MarioEstadoSprite
00033Br 1  60           	RTS
00033Cr 1               realPosicion:
00033Cr 1               	;;Tomo la posicion X
00033Cr 1  18           	CLC
00033Dr 1  A5 rr        	LDA MarioOffsetX
00033Fr 1  29 18        	AND #%00011000
000341r 1               	;;Dividimos por 8 y tomamos solo dos bits (4 estados posibles)
000341r 1  4A           	LSR
000342r 1  4A           	LSR
000343r 1  4A           	LSR
000344r 1  65 rr        	ADC MarioEstadoSprite
000346r 1  85 rr        	STA MarioEstadoSprite
000348r 1               	;;Entonces guardamos el estado en funcion de la coordenada X.
000348r 1  60              RTS
000349r 1               
000349r 1               
000349r 1               ;;Esta rutina detecta si dos Sprites estan colisionando.
000349r 1               ;;Codigo tomado de:
000349r 1               ;;https://refreshgames.co.uk/2018/01/27/nes-asm-tips-box-collision/
000349r 1               ;;Y adaptado a sprite fijo (hongo) y sprite movil (mario)
000349r 1               SUBDetectCollisions:
000349r 1  48           	PHA ; Guarda el acumulador en el stack
00034Ar 1  A9 00        	LDA #$00
00034Cr 1  85 rr        	STA SpriteChoca ;Inicializa SpriteChoca en 0 asumiendo que no choca
00034Er 1               ; Verifica primer caso
00034Er 1  18           	CLC
00034Fr 1  A5 rr        	LDA MarioOffsetX ;Toma coordenada de MarioX
000351r 1  69 10        	ADC #16 ; Dado que tiene 16 de ancho se lo suma
000353r 1  C9 40        	CMP #HONGOX ; Compara con el comienzo del hongo
000355r 1  30 1F        	BMI FinishCollisionCheckBetter ;Si es menor, no puede estar chocando
000357r 1               
000357r 1               ; Verifica segundo caso
000357r 1  18           	CLC
000358r 1  A9 40        	LDA #HONGOX ;Carga coordenada del hongo X
00035Ar 1  69 10        	ADC #16 ; Dado que el hongo es de 16 de ancho, los suma
00035Cr 1  C5 rr        	CMP MarioOffsetX ; Comparo contra el comienzo de mario en X
00035Er 1  30 16        	BMI FinishCollisionCheckBetter ;Si es menor, no puede estar chocando
000360r 1               
000360r 1               ; Verifica tercer caso
000360r 1  18           	CLC
000361r 1  A5 rr        	LDA MarioOffsetY ; Carga la posicion de MArioY
000363r 1  69 10        	ADC #16 ; dado que es de 16 de alto, se los suma
000365r 1  C9 4C        	CMP #HONGOY ; compara con la posicion Y del hongo
000367r 1  30 0D        	BMI FinishCollisionCheckBetter ;Si es menor, no puede estar chocando
000369r 1               
000369r 1               ; Ultimo caso
000369r 1  18           	CLC
00036Ar 1  A9 4C        	LDA #HONGOY ; Carga la posicion Y del hongo
00036Cr 1  69 10        	ADC #16 ; Dado que tiene 16 de alto se los suma
00036Er 1  C5 rr        	CMP MarioOffsetY ; Compara con la posicion Y de mario
000370r 1  30 04        	BMI FinishCollisionCheckBetter ;Si es menor, no puede estar chocando
000372r 1               
000372r 1               ;SI llego hasta aca sin saltar, quiere decir que hay colision
000372r 1  A9 01        	LDA #$01
000374r 1  85 rr        	STA SpriteChoca
000376r 1               
000376r 1               FinishCollisionCheckBetter:
000376r 1  68           	PLA ; Restaura el valor de A del stack
000377r 1               
000377r 1  60           	RTS
000378r 1               
000378r 1               
000378r 1               ;;Esta rutina verifica que pasa con el hongo y si hay choque
000378r 1               ;;usando la rutina de arriba como auxiliar
000378r 1               SUBCheckColisionHongo:
000378r 1  A5 rr        	LDA HongoVisible
00037Ar 1  F0 15        	BEQ finCheckColisionHongo
00037Cr 1               	;;Hay que comparar donde esta mario con los limites del hongo
00037Cr 1  20 rr rr     	JSR SUBDetectCollisions
00037Fr 1  A5 rr        	LDA SpriteChoca
000381r 1  F0 0E        	BEQ finCheckColisionHongo ;;No esta chocando con el hongo
000383r 1               	;;Aca si esta chocando, asi que si el hongo esta visible
000383r 1               	;;lo ocultamos
000383r 1  A9 00        	LDA #0
000385r 1  85 rr        	STA HongoVisible
000387r 1               	;;Sumamos un puntito
000387r 1  20 rr rr     	JSR SUBIncrementarScore
00038Ar 1               	;;Refrezcamos el hongo en pantalla (no se muestra mas)
00038Ar 1  20 rr rr     	JSR SUBDisplayHongo
00038Dr 1               	;;Tocamos LSD
00038Dr 1  A9 01        	LDA #1
00038Fr 1  85 rr        	STA LSDPlaying
000391r 1               finCheckColisionHongo:
000391r 1  60               RTS
000392r 1               
000392r 1               ;;Esta rutina muestra el hongo en pantalla dependiendo de si
000392r 1               ;;la variable HongoVisible esta en 1 o 0.
000392r 1               SUBDisplayHongo:
000392r 1  A5 rr        	LDA HongoVisible
000394r 1  D0 0F        	BNE dibujalo
000396r 1               	;;Si no esta visible, lo dibujamos fuera de pantalla
000396r 1  A9 FF        	LDA #$FF
000398r 1  8D 20 02     	STA $0220
00039Br 1  8D 24 02     	STA $0224
00039Er 1  8D 28 02         STA $0228
0003A1r 1  8D 2C 02         STA $022C
0003A4r 1  60           	RTS
0003A5r 1               ;;Si esta visible, entonces los dibujamos en coordenadas fijas
0003A5r 1               dibujalo:
0003A5r 1  18             CLC
0003A6r 1  A9 4C          LDA #76
0003A8r 1  8D 20 02       STA $0220
0003ABr 1  18             clc
0003ACr 1  A9 40          LDA #64
0003AEr 1  8D 23 02       STA $0223
0003B1r 1  A9 76          LDA #$76
0003B3r 1  8D 21 02       STA $0221
0003B6r 1  A9 01          LDA #$01
0003B8r 1  8D 22 02       STA $0222
0003BBr 1               
0003BBr 1                 ;Seguimos con UpperRight UR
0003BBr 1  18             clc
0003BCr 1  A9 4C          LDA #76
0003BEr 1  8D 24 02       STA $0224
0003C1r 1  18             clc
0003C2r 1  A9 48          LDA #72
0003C4r 1  8D 27 02       STA $0227
0003C7r 1  A9 77          LDA #$77
0003C9r 1  8D 25 02       STA $0225
0003CCr 1  A9 01          LDA #$01
0003CEr 1  8D 26 02       STA $0226
0003D1r 1               
0003D1r 1                 ;Seguimos con LowerLeft LL
0003D1r 1  18             clc
0003D2r 1  A9 54          LDA #84
0003D4r 1  8D 28 02       STA $0228
0003D7r 1  18             clc
0003D8r 1  A9 40          LDA #64
0003DAr 1  8D 2B 02       STA $022B
0003DDr 1  A9 78          LDA #$78
0003DFr 1  8D 29 02       STA $0229
0003E2r 1  A9 01          LDA #$01
0003E4r 1  8D 2A 02       STA $022A
0003E7r 1               
0003E7r 1                 ;Ultimo con lowerRight LR
0003E7r 1  18             clc
0003E8r 1  A9 54          LDA #84
0003EAr 1  8D 2C 02       STA $022C
0003EDr 1  18             clc
0003EEr 1  A9 48          LDA #72
0003F0r 1  8D 2F 02       STA $022F
0003F3r 1  A9 79          LDA #$79
0003F5r 1  8D 2D 02       STA $022D
0003F8r 1  A9 01          LDA #$01
0003FAr 1  8D 2E 02       STA $022E
0003FDr 1               
0003FDr 1  60             RTS
0003FEr 1               
0003FEr 1               
0003FEr 1               ;;Esta rutina se fija si mario choca algo con la cabeza
0003FEr 1               ;;En caso de ser un BOX ? , entonces muestra el hongo
0003FEr 1               SUBCheckCabeza:
0003FEr 1               	;; Esta rutina se fija que no haya nada arriba de la cabeza a mario
0003FEr 1  18           	CLC
0003FFr 1  A5 rr        	LDA MarioOffsetY
000401r 1  E9 01        	SBC #1
000403r 1  85 rr        	STA FindTileY
000405r 1  A9 00        	LDA #0
000407r 1  85 rr        	STA TileCount
000409r 1  A5 rr        	LDA MarioOffsetX
00040Br 1  85 rr        	STA FindTileX
00040Dr 1  20 rr rr     	JSR SUBFindTile
000410r 1               	;; Si hay un $55 o $56 hay un BOX
000410r 1               	;; Si arriba hay algo mayor a $3F sumo
000410r 1  C9 3F        	CMP #$3F
000412r 1  30 0E        	BMI checkCabeza2
000414r 1  E6 rr        	INC TileCount
000416r 1  C9 55        	CMP #$55
000418r 1  D0 02        	BNE checkOtroQuestion
00041Ar 1  E6 rr        	INC HongoVisible
00041Cr 1               checkOtroQuestion:
00041Cr 1  C9 56            CMP #$56
00041Er 1  D0 02            BNE checkCabeza2
000420r 1  E6 rr            INC HongoVisible
000422r 1               checkCabeza2:
000422r 1  18           	CLC
000423r 1  A5 rr        	LDA FindTileX
000425r 1  69 10        	ADC #16
000427r 1  85 rr        	STA FindTileX
000429r 1  20 rr rr     	JSR SUBFindTile
00042Cr 1  C9 3F        	CMP #$3F
00042Er 1  30 0E        	BMI finCheckCabeza
000430r 1  E6 rr            INC TileCount
000432r 1  C9 55        	CMP #$55
000434r 1  D0 02        	BNE checkOtroQuestion1
000436r 1  E6 rr        	INC HongoVisible
000438r 1               checkOtroQuestion1:
000438r 1  C9 56            CMP #$56
00043Ar 1  D0 02            BNE finCheckCabeza
00043Cr 1  E6 rr            INC HongoVisible
00043Er 1               finCheckCabeza:
00043Er 1  A5 rr            LDA TileCount
000440r 1  60               RTS
000441r 1               
000441r 1               ;;Esta rutina se fija si mario esta saltando y procesa el salto.
000441r 1               SUBCheckSalto:
000441r 1                   ;;No puede haber gravedad aun, ya que se resetea cada vez que se
000441r 1                   ;; dibuja  a mario
000441r 1                   ;; El BMS de MArioEstadoSalto indica si esta saltando o no
000441r 1  A5 rr            LDA MarioEstadoSalto
000443r 1  29 80            AND #%10000000
000445r 1  F0 52            BEQ finCheckSalto
000447r 1                   ;;Dado que MarioEstadoSalto tiene 10xxxxxx
000447r 1                   ;;podemos vemos si subimos o bajamos
000447r 1  A5 rr            LDA MarioEstadoSalto
000449r 1  C9 97            CMP #%10010111
00044Br 1  10 15            BPL Bajando
00044Dr 1                   ;;Si estoy aca es porque esta subiendo con el salto
00044Dr 1  E6 rr            INC MarioEstadoSalto
00044Fr 1                   ;;HAy que verificar que no haya nada en la cabeza de mario
00044Fr 1  20 rr rr         JSR SUBCheckCabeza
000452r 1                   ;;Si devolvio 0 es que se puede saltar
000452r 1  D0 0A            BNE ChocoCabeza
000454r 1  18               CLC
000455r 1  A5 rr            LDA MarioOffsetY
000457r 1  E9 02            SBC #2
000459r 1  85 rr            STA MarioOffsetY
00045Br 1  4C rr rr         JMP finCheckSalto
00045Er 1               
00045Er 1               ChocoCabeza:
00045Er 1                   ;;Como choco la cabeza paramos de subir
00045Er 1  A9 9F            LDA #%10011111
000460r 1  85 rr            STA MarioEstadoSalto
000462r 1               
000462r 1               Bajando:
000462r 1               	;; SI esta bajando, tenemos que bajar hasta que choca con algo
000462r 1               	;; entonces copiamos la rutina que verifica por gravedad
000462r 1  A9 00        	LDA #0
000464r 1  85 rr        	STA TileCount
000466r 1  18           	CLC
000467r 1  A5 rr        	LDA MarioOffsetY
000469r 1  69 12        	ADC #18
00046Br 1  85 rr        	STA FindTileY
00046Dr 1  A5 rr        	LDA MarioOffsetX
00046Fr 1  85 rr        	STA FindTileX
000471r 1  20 rr rr     	JSR SUBFindTile
000474r 1               	;;Ahora A tiene el tile a abajo
000474r 1  C9 3F        	CMP #$3F
000476r 1  10 02        	BPL nadaXcayendo
000478r 1  E6 rr        	INC TileCount
00047Ar 1               nadaXcayendo:
00047Ar 1  18           	CLC
00047Br 1  A5 rr        	LDA MarioOffsetX
00047Dr 1  69 10        	ADC #16
00047Fr 1  85 rr        	STA FindTileX
000481r 1  20 rr rr     	JSR SUBFindTile
000484r 1  C9 3F        	CMP #$3F
000486r 1  10 02        	BPL finCayendo
000488r 1  E6 rr        	INC TileCount
00048Ar 1               
00048Ar 1               finCayendo:
00048Ar 1  A5 rr           LDA TileCount
00048Cr 1  C9 02           CMP #$02
00048Er 1  D0 05           BNE impactoSuelo
000490r 1  E6 rr           INC MarioOffsetY
000492r 1  E6 rr           INC MarioOffsetY
000494r 1  60              RTS
000495r 1               
000495r 1               impactoSuelo:
000495r 1                  ;;No cae mas
000495r 1  A9 00           LDA #$00
000497r 1  85 rr           STA MarioEstadoSalto
000499r 1               
000499r 1               finCheckSalto:
000499r 1  60               RTS
00049Ar 1               
00049Ar 1               
00049Ar 1               ;;Esta es la rutina principal que actualiza todos los Sprites.
00049Ar 1               SUBDibujaMario:
00049Ar 1               	;; Primero reseteo el flag de cayendo por gravedad
00049Ar 1               	;; ya que  lo vamos a chequear siempre despues de ver si esta
00049Ar 1               	;; saltando o no.
00049Ar 1  A5 rr        	LDA MarioEstadoSalto
00049Cr 1  29 BF        	AND #%10111111
00049Er 1  85 rr        	STA MarioEstadoSalto
0004A0r 1               	;; Primero vemos si esta saltando
0004A0r 1  20 rr rr     	JSR SUBCheckSalto
0004A3r 1               	;; Ahora que ya sabemos si salta o no, vemos si se cae por gravedad
0004A3r 1  20 rr rr     	JSR SUBAplicarGravedad
0004A6r 1               
0004A6r 1               	;;Dado que la posicion X, Y ya esta actualizada podemos actualizar
0004A6r 1               	;;como se dibuja mario en pantalla
0004A6r 1  20 rr rr     	JSR SUBActualizaEstadoMario
0004A9r 1               	;;Vemos si choco con el hongo y lo mostramos
0004A9r 1  20 rr rr     	JSR SUBCheckColisionHongo
0004ACr 1  20 rr rr     	JSR SUBDisplayHongo
0004AFr 1               
0004AFr 1               	;; Ahora que su estado esta actualizado podemos dibujarlo.
0004AFr 1               	;; Apuntamos a donde estan los sprites relativos al estado
0004AFr 1               	;; y buscamos los mismos con la variable de estado.
0004AFr 1  A5 rr        	LDA MarioEstadoSprite
0004B1r 1  C9 70        	CMP #$70
0004B3r 1  10 0B        	BPL parteIzquierda
0004B5r 1  A9 rr            LDA #<dbEstadoMario00
0004B7r 1  85 rr            STA MarioEstadoSpritedb
0004B9r 1  A9 rr            LDA #>dbEstadoMario00
0004BBr 1  85 rr            STA MarioEstadoSpritedb+1
0004BDr 1  4C rr rr         JMP sumarBajo
0004C0r 1               parteIzquierda:
0004C0r 1  A9 rr            LDA #<dbEstadoMario80
0004C2r 1  85 rr            STA MarioEstadoSpritedb
0004C4r 1  A9 rr            LDA #>dbEstadoMario80
0004C6r 1  85 rr            STA MarioEstadoSpritedb+1
0004C8r 1               
0004C8r 1               sumarBajo:
0004C8r 1  A5 rr            LDA MarioEstadoSprite
0004CAr 1  29 0F            AND #$0F
0004CCr 1  0A               asl
0004CDr 1  0A               asl
0004CEr 1  0A               asl
0004CFr 1  65 rr            ADC MarioEstadoSpritedb
0004D1r 1  85 rr            STA MarioEstadoSpritedb
0004D3r 1  90 02            BCC actualizaSprite
0004D5r 1  E6 rr            INC MarioEstadoSpritedb+1
0004D7r 1               
0004D7r 1               ;; Ahora MarioEstadoSpritedb apunta a un vector que tiene
0004D7r 1               ;; todos los valores para los sprites
0004D7r 1               ;; Cada parte de mario (UL, UR, LL, LR) necesita un valor de sprite
0004D7r 1               ;; y un atributo asi que cargamos los 8 valores
0004D7r 1               actualizaSprite:
0004D7r 1  A0 00            LDY #0
0004D9r 1  B1 rr            lda (MarioEstadoSpritedb), y
0004DBr 1  8D 11 02         STA $0211
0004DEr 1  C8               INY
0004DFr 1  B1 rr            LDA (MarioEstadoSpritedb), y
0004E1r 1  8D 19 02         STA $0219
0004E4r 1  C8               INY
0004E5r 1  B1 rr            LDA (MarioEstadoSpritedb), y
0004E7r 1  8D 15 02         STA $0215
0004EAr 1  C8               INY
0004EBr 1  B1 rr            LDA (MarioEstadoSpritedb), y
0004EDr 1  8D 1D 02         STA $021D
0004F0r 1  C8               INY
0004F1r 1  B1 rr            LDA (MarioEstadoSpritedb), y
0004F3r 1  8D 12 02         STA $0212
0004F6r 1  C8               INY
0004F7r 1  B1 rr            LDA (MarioEstadoSpritedb), y
0004F9r 1  8D 1A 02         STA $021A
0004FCr 1  C8               INY
0004FDr 1  B1 rr            LDA (MarioEstadoSpritedb), y
0004FFr 1  8D 16 02         STA $0216
000502r 1  C8               INY
000503r 1  B1 rr            LDA (MarioEstadoSpritedb), y
000505r 1  8D 1E 02         STA $021E
000508r 1                   ;;Ahora que ya se cargo como se dibuja mario le decimos en donde
000508r 1                   ;;Lo tiene que dibujar (cada parte)
000508r 1  18               CLC
000509r 1  A5 rr            LDA MarioOffsetY
00050Br 1  8D 10 02         STA $0210
00050Er 1  8D 18 02         STA $0218
000511r 1  69 08            ADC #$08
000513r 1  8D 14 02         STA $0214
000516r 1  8D 1C 02         STA $021C
000519r 1               
000519r 1  18               CLC
00051Ar 1  A5 rr            LDA MarioOffsetX
00051Cr 1  8D 13 02         STA $0213
00051Fr 1  8D 17 02         STA $0217
000522r 1  69 08            ADC #$08
000524r 1  8D 1B 02         STA $021B
000527r 1  8D 1F 02         STA $021F
00052Ar 1               
00052Ar 1  60           	RTS
00052Br 1               
00052Br 1               ;;Tabla de estados de mario. Guarda primero el numero de sprite
00052Br 1               ;; y luego guarda el atributo correspondiente
00052Br 1               
00052Br 1               dbEstadoMario00: ;Moviendose Derecha etapa 0 (manos separadas)
00052Br 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
00052Br 1  36 37 38 39  	.byte $36,$37,$38,$39,$0,$0,$0,$0
00052Fr 1  00 00 00 00  
000533r 1               dbEstadoMario01: ;Moviendose Derecha etapa 1 (manos juntas)
000533r 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
000533r 1  3A 37 3B 3C  	.byte $3A,$37,$3B,$3C,$0,$0,$0,$0
000537r 1  00 00 00 00  
00053Br 1               dbEstadoMario02: ;Moviendose Derecha etapa 2 (mano adelante)
00053Br 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
00053Br 1  32 33 34 35  	.byte $32,$33,$34,$35,$0,$0,$0,$0
00053Fr 1  00 00 00 00  
000543r 1               dbEstadoMario03: ;Moviendose Derecha etapa 3 (manos juntas)
000543r 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
000543r 1  3A 37 3B 3C  	.byte $3A,$37,$3B,$3C,$0,$0,$0,$0
000547r 1  00 00 00 00  
00054Br 1               dbEstadoMario04: ;Mario quieto mirando a la derecha
00054Br 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
00054Br 1  32 33 4F 4F  	.byte $32,$33,$4F,$4F,$0,$0,$0,$40
00054Fr 1  00 00 00 40  
000553r 1               dbEstadoMario05: ;Salto positivo a la derecha
000553r 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
000553r 1  32 41 42 43  	.byte $32,$41,$42,$43,$0,$0,$0,$0
000557r 1  00 00 00 00  
00055Br 1               
00055Br 1               dbEstadoMario80: ;Moviendose Derecha etapa 0 (manos separadas)
00055Br 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
00055Br 1  37 36 39 38  	.byte $37,$36,$39,$38,$40,$40,$40,$40
00055Fr 1  40 40 40 40  
000563r 1               dbEstadoMario81: ;Moviendose Derecha etapa 1 (manos juntas)
000563r 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
000563r 1  37 3A 3C 3B  	.byte $37,$3A,$3C,$3B,$40,$40,$40,$40
000567r 1  40 40 40 40  
00056Br 1               dbEstadoMario82: ;Moviendose Derecha etapa 2 (mano adelante)
00056Br 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
00056Br 1  33 32 35 34  	.byte $33,$32,$35,$34,$40,$40,$40,$40
00056Fr 1  40 40 40 40  
000573r 1               dbEstadoMario83: ;Moviendose Derecha etapa 3 (manos juntas)
000573r 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
000573r 1  37 3A 3C 3B  	.byte $37,$3A,$3C,$3B,$40,$40,$40,$40
000577r 1  40 40 40 40  
00057Br 1               dbEstadoMario84: ;Mario quieto mirando a la derecha
00057Br 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
00057Br 1  33 32 4F 4F  	.byte $33,$32,$4F,$4F,$40,$40,$0,$40
00057Fr 1  40 40 00 40  
000583r 1               dbEstadoMario85: ;Salto positivo a la derecha
000583r 1                         ;UL, UR, LL, LR,UL,UR,LL, LR
000583r 1  41 32 43 42  	.byte $41,$32,$43,$42,$40,$40,$40,$40
000587r 1  40 40 40 40  
00058Br 1               
00058Br 1               
00058Br 1               
00058Br 1               ;; Esta rutina dibuja el fondo (Background Tiles).
00058Br 1               SUBDibujaFondo:
00058Br 1  AD 02 20       LDA $2002             ; Hay que leer el PPU para resetear la posicion
00058Er 1  A9 20          LDA #$20
000590r 1  8D 06 20       STA $2006             ; Se carga la parte alta de $2000
000593r 1  A9 00          LDA #$00
000595r 1  8D 06 20       STA $2006             ; Se carga la parte baja de $2000
000598r 1  A2 00          LDX #$00
00059Ar 1                 ;;Una pantalla entera tiene 32x30 tiles, o sea 960 bytes.
00059Ar 1                 ;;Pero el registro X es de 8 bits, por ende tenemos que cargar
00059Ar 1                 ;;de 256 bytes a la vez o usar modo indirecto indexado pero hay que
00059Ar 1                 ;;contar con 16 bits, asi que es mas facil cargarlo por partes.
00059Ar 1               
00059Ar 1                 ;;Cargamos los primeros 256 bytes
00059Ar 1               LoadBackgroundLoop:
00059Ar 1  BD rr rr       LDA NewWorld, x
00059Dr 1  8D 07 20       STA $2007              ;Grabamos el valor a PPU, que se autoincrementa
0005A0r 1  E8             INX                    ; incrementamos X para el loop.
0005A1r 1  E0 65          CPX #$65               ; en $65 corta para cargar el SCORE, sino sigue
0005A3r 1  D0 F5          BNE LoadBackgroundLoop ; Mientras no haya recorrido los $65, que siga.
0005A5r 1               
0005A5r 1                 ;;Cargamos los puntos en el medio de los primeros 256
0005A5r 1  A5 rr          LDA Puntos1
0005A7r 1  8D 07 20       STA $2007
0005AAr 1  A5 rr          LDA Puntos0
0005ACr 1  8D 07 20       STA $2007
0005AFr 1  A2 67          LDX #$67
0005B1r 1               
0005B1r 1               LoadBackgroundLoopPos:
0005B1r 1  BD rr rr       LDA NewWorld, x
0005B4r 1  8D 07 20       STA $2007
0005B7r 1  E8             INX
0005B8r 1  E0 00          CPX #$00
0005BAr 1  D0 F5          BNE LoadBackgroundLoopPos ;Si no llego a 00, no termino aun.
0005BCr 1               
0005BCr 1                 ;;Todos los loops son mas o menos iguales
0005BCr 1                 ;; pero con el offset avanzado en 256
0005BCr 1               
0005BCr 1               LoadBackgroundLoop256:
0005BCr 1  BD rr rr       LDA NewWorld+256, x
0005BFr 1  8D 07 20       STA $2007
0005C2r 1  E8             INX
0005C3r 1  E0 00          CPX #$00
0005C5r 1  D0 F5          BNE LoadBackgroundLoop256
0005C7r 1               
0005C7r 1               LoadBackgroundLoop512:
0005C7r 1  BD rr rr       LDA NewWorld+512, x
0005CAr 1  8D 07 20       STA $2007
0005CDr 1  E8             INX
0005CEr 1  E0 00          CPX #$00
0005D0r 1  D0 F5          BNE LoadBackgroundLoop512
0005D2r 1               
0005D2r 1                 ;;Este ultimo loop tiene que ir desde 768 hasta 960 solamente
0005D2r 1               
0005D2r 1               LoadBackgroundLoop192:
0005D2r 1  BD rr rr       LDA NewWorld+512+256, x
0005D5r 1  8D 07 20       STA $2007
0005D8r 1  E8             INX
0005D9r 1  E0 C0          CPX #192
0005DBr 1  D0 F5          BNE LoadBackgroundLoop192
0005DDr 1               
0005DDr 1                ;;Este loop carga los registros de atributos que estan a continuacion de los tiles.
0005DDr 1                ;;Comienza apuntando el PPU a la memoria de atributos correspondiente
0005DDr 1               
0005DDr 1               LoadAttribute:
0005DDr 1  AD 02 20       LDA $2002
0005E0r 1  A9 23          LDA #$23
0005E2r 1  8D 06 20       STA $2006
0005E5r 1  A9 C0          LDA #$C0
0005E7r 1  8D 06 20       STA $2006
0005EAr 1  A2 00          LDX #$00
0005ECr 1               
0005ECr 1                 ;;Ahora barremos los atributos y los vamos pasando al PPU
0005ECr 1               LoadAttributeLoop:
0005ECr 1  BD rr rr       LDA NewWorldAttribute, x
0005EFr 1  8D 07 20       STA $2007
0005F2r 1  E8             INX
0005F3r 1  E0 40          CPX #64
0005F5r 1  D0 F5          BNE LoadAttributeLoop
0005F7r 1               
0005F7r 1                 ;;Todo listo, podemos volver
0005F7r 1  60             RTS
0005F8r 1               
0005F8r 1               ;;Cargamos los tiempos para el timer que genera las notas musicales
0005F8r 1               ;;con el Pulse1 del PPU
0005F8r 1               NOTAS:
0005F8r 1  AB           	.byte %10101011 ;, %1
0005F9r 1  93           	.byte %10010011 ;, %1
0005FAr 1  7C           	.byte %01111100 ;, %1
0005FBr 1  67           	.byte %01100111 ;, %1
0005FCr 1  52           	.byte %01010010 ;, %1
0005FDr 1  3F           	.byte %00111111 ;, %1
0005FEr 1  2D           	.byte %00101101 ;, %1
0005FFr 1  1C           	.byte %00011100 ;, %1
000600r 1  0C           	.byte %00001100 ;, %1
000601r 1  FD           	.byte %11111101 ;, %0
000602r 1  EF           	.byte %11101111 ;, %0
000603r 1  E1           	.byte %11100001 ;, %0
000604r 1  D5           	.byte %11010101 ;, %0
000605r 1  C9           	.byte %11001001 ;, %0
000606r 1  BD           	.byte %10111101 ;, %0
000607r 1  B3           	.byte %10110011 ;, %0
000608r 1  A9           	.byte %10101001 ;, %0
000609r 1  9F           	.byte %10011111 ;, %0
00060Ar 1  96           	.byte %10010110 ;, %0
00060Br 1  8E           	.byte %10001110 ;, %0
00060Cr 1  86           	.byte %10000110 ;, %0
00060Dr 1  7E           	.byte %01111110 ;, %0
00060Er 1  77           	.byte %01110111 ;, %0
00060Fr 1  70           	.byte %01110000 ;, %0
000610r 1  00           	.byte $00
000611r 1               
000611r 1               ;;Cargamos el mapa estatico original (NameTable) con atributos
000611r 1               NewWorld:
000611r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000615r 1  24 24 24 24  
000619r 1  24 24 24 24  
000621r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000625r 1  24 24 24 24  
000629r 1  24 24 24 24  
000631r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000635r 1  24 24 24 24  
000639r 1  24 24 24 24  
000641r 1  24 36 37 24  	.byte $24,$36,$37,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000645r 1  24 24 24 24  
000649r 1  24 24 24 24  
000651r 1  24 24 24 19  	.byte $24,$24,$24,$19,$1e,$17,$1d,$18,$1c,$24,$24,$24,$24,$24,$24,$24
000655r 1  1E 17 1D 18  
000659r 1  1C 24 24 24  
000661r 1  35 25 25 38  	.byte $35,$25,$25,$38,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000665r 1  24 24 24 24  
000669r 1  24 24 24 24  
000671r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$00,$00,$24,$24,$24,$24,$24,$24,$24,$24,$24
000675r 1  24 00 00 24  
000679r 1  24 24 24 24  
000681r 1  39 3A 3B 3C  	.byte $39,$3a,$3b,$3c,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000685r 1  24 24 24 24  
000689r 1  24 24 24 24  
000691r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000695r 1  24 24 24 24  
000699r 1  24 24 24 24  
0006A1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0006A5r 1  24 24 24 24  
0006A9r 1  24 24 24 24  
0006B1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0006B5r 1  24 24 24 24  
0006B9r 1  24 24 24 24  
0006C1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0006C5r 1  24 24 24 24  
0006C9r 1  24 24 24 24  
0006D1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0006D5r 1  24 24 24 24  
0006D9r 1  24 24 24 24  
0006E1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0006E5r 1  24 24 24 24  
0006E9r 1  24 24 24 24  
0006F1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0006F5r 1  24 24 24 24  
0006F9r 1  24 24 24 24  
000701r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000705r 1  24 24 24 24  
000709r 1  24 24 24 24  
000711r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000715r 1  24 24 24 24  
000719r 1  24 24 24 24  
000721r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000725r 1  24 24 24 24  
000729r 1  24 24 24 24  
000731r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000735r 1  24 24 24 24  
000739r 1  24 24 24 24  
000741r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000745r 1  24 24 24 24  
000749r 1  24 24 24 24  
000751r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000755r 1  24 24 24 24  
000759r 1  24 24 24 24  
000761r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000765r 1  24 24 24 24  
000769r 1  24 24 24 24  
000771r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000775r 1  24 24 24 24  
000779r 1  24 24 24 24  
000781r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000785r 1  24 24 24 24  
000789r 1  24 24 24 24  
000791r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$53,$54,$24,$24,$24,$24,$24,$24
000795r 1  24 24 24 24  
000799r 1  53 54 24 24  
0007A1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$b0,$b2,$b0,$b2,$b0,$b2,$24,$24,$24,$24
0007A5r 1  24 24 B0 B2  
0007A9r 1  B0 B2 B0 B2  
0007B1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$55,$56,$24,$24,$24,$24,$24,$24
0007B5r 1  24 24 24 24  
0007B9r 1  55 56 24 24  
0007C1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$b1,$b3,$b1,$b3,$b1,$b3,$24,$24,$24,$24
0007C5r 1  24 24 B1 B3  
0007C9r 1  B1 B3 B1 B3  
0007D1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0007D5r 1  24 24 24 24  
0007D9r 1  24 24 24 24  
0007E1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0007E5r 1  24 24 24 24  
0007E9r 1  24 24 24 24  
0007F1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0007F5r 1  24 24 24 24  
0007F9r 1  24 24 24 24  
000801r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000805r 1  24 24 24 24  
000809r 1  24 24 24 24  
000811r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000815r 1  24 24 24 24  
000819r 1  24 24 24 24  
000821r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000825r 1  24 24 24 24  
000829r 1  24 24 24 24  
000831r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000835r 1  24 24 24 24  
000839r 1  24 24 24 24  
000841r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000845r 1  24 24 24 24  
000849r 1  24 24 24 24  
000851r 1  24 24 24 24  	.byte $24,$24,$24,$24,$45,$45,$45,$45,$45,$45,$45,$45,$24,$24,$24,$24
000855r 1  45 45 45 45  
000859r 1  45 45 45 45  
000861r 1  24 45 45 45  	.byte $24,$45,$45,$45,$45,$45,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000865r 1  45 45 24 24  
000869r 1  24 24 24 24  
000871r 1  24 24 24 24  	.byte $24,$24,$24,$24,$47,$47,$47,$47,$47,$47,$47,$47,$24,$24,$24,$24
000875r 1  47 47 47 47  
000879r 1  47 47 47 47  
000881r 1  24 47 47 47  	.byte $24,$47,$47,$47,$47,$47,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000885r 1  47 47 24 24  
000889r 1  24 24 24 24  
000891r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
000895r 1  24 24 24 24  
000899r 1  24 24 24 24  
0008A1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0008A5r 1  24 24 24 24  
0008A9r 1  24 24 24 24  
0008B1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0008B5r 1  24 24 24 24  
0008B9r 1  24 24 24 24  
0008C1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0008C5r 1  24 24 24 24  
0008C9r 1  24 24 24 24  
0008D1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0008D5r 1  24 24 24 24  
0008D9r 1  24 24 24 24  
0008E1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0008E5r 1  24 24 24 24  
0008E9r 1  24 24 24 24  
0008F1r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
0008F5r 1  24 24 24 24  
0008F9r 1  24 24 24 24  
000901r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$60,$61,$62,$63,$24,$24,$24,$24
000905r 1  24 24 24 24  
000909r 1  60 61 62 63  
000911r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$31
000915r 1  24 24 24 24  
000919r 1  24 24 24 24  
000921r 1  32 24 24 24  	.byte $32,$24,$24,$24,$24,$24,$24,$24,$64,$65,$66,$67,$24,$24,$24,$24
000925r 1  24 24 24 24  
000929r 1  64 65 66 67  
000931r 1  24 24 24 24  	.byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$30,$34
000935r 1  24 24 24 24  
000939r 1  24 24 24 24  
000941r 1  26 33 24 24  	.byte $26,$33,$24,$24,$24,$24,$24,$24,$68,$69,$26,$6a,$24,$24,$24,$24
000945r 1  24 24 24 24  
000949r 1  68 69 26 6A  
000951r 1  24 24 36 37  	.byte $24,$24,$36,$37,$24,$24,$24,$24,$24,$24,$24,$24,$24,$30,$26,$26
000955r 1  24 24 24 24  
000959r 1  24 24 24 24  
000961r 1  26 34 33 24  	.byte $26,$34,$33,$24,$24,$24,$24,$24,$68,$69,$26,$6a,$24,$24,$24,$24
000965r 1  24 24 24 24  
000969r 1  68 69 26 6A  
000971r 1  24 35 25 25  	.byte $24,$35,$25,$25,$38,$24,$24,$24,$24,$24,$24,$24,$30,$26,$34,$26
000975r 1  38 24 24 24  
000979r 1  24 24 24 24  
000981r 1  26 26 26 33  	.byte $26,$26,$26,$33,$24,$24,$24,$24,$68,$69,$26,$6a,$24,$24,$24,$24
000985r 1  24 24 24 24  
000989r 1  68 69 26 6A  
000991r 1  B4 B5 B4 B5  	.byte $b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5
000995r 1  B4 B5 B4 B5  
000999r 1  B4 B5 B4 B5  
0009A1r 1  B4 B5 B4 B5  	.byte $b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5,$b4,$b5
0009A5r 1  B4 B5 B4 B5  
0009A9r 1  B4 B5 B4 B5  
0009B1r 1  B6 B7 B6 B7  	.byte $b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7
0009B5r 1  B6 B7 B6 B7  
0009B9r 1  B6 B7 B6 B7  
0009C1r 1  B6 B7 B6 B7  	.byte $b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7,$b6,$b7
0009C5r 1  B6 B7 B6 B7  
0009C9r 1  B6 B7 B6 B7  
0009D1r 1               NewWorldAttribute:
0009D1r 1  54 50 50 00  	.byte $54,$50,$50,$00,$55,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
0009D5r 1  55 01 00 00  
0009D9r 1  00 00 00 00  
0009E1r 1  00 00 00 00  	.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$04,$05,$00
0009E5r 1  00 00 00 00  
0009E9r 1  00 00 00 00  
0009F1r 1  00 A0 A0 00  	.byte $00,$a0,$a0,$00,$a0,$20,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$00
0009F5r 1  A0 20 00 00  
0009F9r 1  00 00 00 00  
000A01r 1  F0 B0 A0 FC  	.byte $f0,$b0,$a0,$fc,$f3,$a0,$ff,$00,$0a,$0a,$0a,$0a,$0a,$0a,$0a,$0a
000A05r 1  F3 A0 FF 00  
000A09r 1  0A 0A 0A 0A  
000A11r 1               ;;Paleta de colores original
000A11r 1               NewWorldPalette:
000A11r 1               ;	.byte $21,$27,$16,$0f,$21,$20,$21,$0f,$21,$20,$16,$0f,$21,$2a,$1a,$0f
000A11r 1  21 27 16 0F      .byte $21,$27,$16,$0f,$21,$20,$21,$0f,$21,$37,$16,$0f,$21,$2a,$1a,$0f
000A15r 1  21 20 21 0F  
000A19r 1  21 37 16 0F  
000A21r 1  21 16 27 18      .byte $21,MEDIUM_RED,LIGHT_ORANGE,MEDIUM_YELLOW
000A25r 1  27 16 20 27      .byte  LIGHT_ORANGE,MEDIUM_RED,$20,LIGHT_ORANGE
000A29r 1  0F 16 16 29      .byte  BLACK,MEDIUM_RED,MEDIUM_RED,LIGHT_CHARTREUSE
000A2Dr 1  0F 16 16 29      .byte  BLACK,MEDIUM_RED,MEDIUM_RED,LIGHT_CHARTREUSE
000A31r 1               
000A31r 1               
000A31r 1               
000A31r 1               
000A31r 1               
000A31r 1               
000A31r 1               
000A31r 1               .segment "VECTORS" ; Direcciones para las ISR (rutinas de interrupcion)
000000r 1  rr rr        .word nmi
000002r 1  rr rr        .word reset
000004r 1  rr rr        .word irq
000004r 1               
